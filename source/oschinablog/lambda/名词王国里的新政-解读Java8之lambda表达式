<h2>名词王国里的新政-解读Java8之lambda表达式</h2><div class="BlogContent">
 <p>前几天在reddit上看到Java8 M8 Developer Preview版本已经发布了，不免想要尝鲜一把。Developer Preview版本已经所有Feature都完成了，Java8的特性可以在这里看到<a href="http://openjdk.java.net/projects/jdk8/features" rel="nofollow">http://openjdk.java.net/projects/jdk8/features</a>，下载地址：<a href="http://jdk8.java.net/download.html" rel="nofollow">http://jdk8.java.net/download.html</a>。Java8最值得期待的就是lambda表达式了，本文就将带你体验lambda表达式，并进行比较深入的解析。</p> 
 <span id="OSC_h2_1"></span> 
 <h2>下载及配置</h2> 
 <p>Intellij IDEA已经完美支持Java8了。首先打开Project Structure，在Project里设置新的JDK路径，并设置Modules=&gt;Source=&gt;Language Level为8.0即可。</p> 
 <p>现在我们可以使用Java8编写程序了！但是当我们开开心心编写完，享受到高级的lambda表达式后，运行程序，会提示：<code>java: Compilation failed: internal java compiler error</code>！这是因为javacc的版本还不对，在Compiler=&gt;Java Compiler里将项目对应的javacc版本选为1.8即可。</p> 
 <p>什么？你说你用Eclipse？好像目前还没有稳定版！想尝鲜的，可以看看这个地址<a href="http://stackoverflow.com/questions/13295275/programming-java-8-in-eclipse" rel="nofollow">http://stackoverflow.com/questions/13295275/programming-java-8-in-eclipse</a>，大致是先checkout Eclipse JDT的beta java8分支，然后在Eclipse里运行这个项目，从而启动一个支持java8的Eclipse…不过应该难不倒作为geek的你吧！</p> 
 <span id="OSC_h2_2"></span> 
 <h2>体验lambda表达式</h2> 
 <p>好了，我们开始体验Java8的新特性-lambda表达式吧！现在我们的匿名类可以写成这样子了：</p> 
 <pre class="brush: java; auto-links: false;">new Thread(() -&gt; {
        System.out.println(&quot;Foo&quot;);
    }).start();</pre> 
 <p>而之前的写法只能是这样子：</p> 
 <pre class="brush: java; auto-links: false;">new Thread(new Runnable() {
        @Override
        public void run() {
            System.out.println(&quot;Foo&quot;);
        }
    }).start();</pre> 
 <p>这样一看，我们似乎就是匿名类写起来简单了一点啊？而第二种方法，借助便捷的IDE，好像编写效率也没什么差别？博主开始也是这样认为，仔细学习之后，才知道其中的奥妙所在！</p> 
 <p>这里有一个重要的信息，就是<strong><code>()-&gt;{}</code>这里代表一个函数，而非一个对象。</strong>可能这么说比较抽象，我们还是代码说话吧：</p> 
 <pre class="brush: java; auto-links: false;">public class LambdaTest {

    private static void bar(){
        System.out.println(&quot;bar&quot;);
    }

    public static void main(String[] args) {
        new Thread(LambdaTest::bar).start();
    }

}</pre> 
 <p>看懂了么？这里<code>LambdaTest::bar</code>代表一个函数(用C++的同学笑了)，而new Thread(Runnable runnable)的参数，可以接受是一个函数作为参数！</p> 
 <p>是不是觉得很神奇，颠覆了Java思维？在剖析原理以前，博主暂且卖个关子，我们先来讲讲什么是lambda表达式。</p> 
 <span id="OSC_h2_3"></span> 
 <h2>什么是lambda表达式</h2> 
 <span id="OSC_h3_4"></span> 
 <h3>lambda表达式的由来</h3> 
 <p>絮叨几句，现代编程语言的lamdba表达式都来自1930年代初，阿隆佐&middot;邱奇(Alonzo Church)提出的λ演算(Lambda calculus)理论。λ演算的核心思想就是“万物皆函数”。一个λ算子即一个函数，其一般形式是<code>λx.x + 2</code>。一个λ算子可以作为另一个λ算子的输入，从而构建一个高阶的函数。λ演算是函数式编程的鼻祖，大名鼎鼎的编程语言Lisp就是基于λ演算而建立。用过Lisp的应该都清楚，它的语法很简单，但是却有包容万物的能力。</p> 
 <p>可能搞计算机的对邱奇比较陌生，但是提起和邱奇同时代的另外一个人，大家就会觉得如雷贯耳了，那就是阿兰&middot;图灵。邱奇成名的时候，图灵还是个大学生。邱奇和图灵一起发表了邱奇-图灵论题，并分别提出了λ演算和图灵机，加上哥德尔提出的递归函数一起，在理论上确定了什么是可计算性。至于什么是可计算性，其实博主也说不清楚，但是现代所有计算机程序语言，都可以认为是从三种之一发展而来，并与之等价的。仅此一点，其影响深远，可想而知。当年教我们《计算理论》的是一个德高望重的教授，人称宋公，每次讲到那个辉煌的年代，总是要停下来，神情专注的感叹一句：“伟大啊！”想想确实挺伟大，人家图灵大学时候就奠定了现代计算机的基础，而我们那会大概还在打DOTA…</p> 
 <p>附上大神们的照片，大家感受一下：</p> 
 <p><img src="http://static.oschina.net/uploads/space/2013/0914/160058_HLj3_190591.png" alt="turing etc." /></p> 
 <span id="OSC_h3_5"></span> 
 <h3>现代编程语言中的lambda表达式</h3> 
 <p>好了扯远了，神游过了那个伟大的时代，我们继续思考如何编代码做需求吧…</p> 
 <p>现代语言的lambda表达式，大概具备几个特征(博主自己归纳的，如有不严谨，欢迎指正)：</p> 
 <ol> 
  <li>函数可作为输入；</li> 
  <li>函数可作为输出；</li> 
  <li>函数可作用在函数上，形成高阶函数。</li> 
  <li>函数支持lambda格式的定义。</li> 
 </ol> 
 <p>其实有了1、2，3也就是顺水推舟的事情，而4其实没有太大的必要性，因为一般语言都有自己的函数定义方式，4仅仅是作为一种补充。当然实现了4的语言，一般都会说：“你看我实现了lambda表达式！”(望向Java8和Python同学)</p> 
 <span id="OSC_h2_6"></span> 
 <h2>在Java8中使用lambda表达式</h2> 
 <span id="OSC_h3_7"></span> 
 <h3>FunctionalInterface</h3> 
 <p>Java中的lambda无法单独出现，它需要一个接口来盛放。这个接口必须使用@FunctionalInterface作为注解，并且只有一个未实现的方法。等等，什么叫接口中未实现的方法？难道接口中还可以有已实现的方法？恭喜你，猜对了！Java8的接口也可以写实现了！是不是觉得Interface和AbstractClass更加傻傻分不清楚了？但是AbstractClass是无法使用@FunctionalInterface注解的，官方的解释是为了防止AbstractClass的构造函数做一些事情，可能会导致一些调用者意料不到的事情发生。</p> 
 <p>好了，我们来看一点代码，Runnable接口现在变成了这个样子：</p> 
 <pre class="brush: java; auto-links: false;">@FunctionalInterface
public interface Runnable {
    public abstract void run();
}</pre> 
 <p>这里我们可以将任意无参数的lambda表达式赋值给Runnable:</p> 
 <pre class="brush: java; auto-links: false;">Runnable runnable = () -&gt; {
        System.out.println(&quot;Hello lambda!&quot;);
    };
    runnable.run();</pre> 
 <p>lambda表达式本质上是一个函数，所以我们还可以用更加神奇的赋值：</p> 
 <pre class="brush: java; auto-links: false;">public class HelloLambda {

    private static void hellolambda() {
        System.out.println(&quot;Hello lambda!&quot;);
    }

    public static void main(String[] args) {
        Runnable runnable = HelloLambda::hellolambda;
        runnable.run();
    }
}</pre> 
 <p>这里看到这里，大家大概明白了，lambda表达式其实只是个幌子，更深层次的含义是：函数在Java里面可以作为一个实体进行表示了。这就意味着，在Java8里，函数既可以作为函数的参数，也可以作为函数的返回值，即具有了lambda演算的所有特性。</p> 
 <span id="OSC_h3_8"></span> 
 <h3>Function系列API</h3> 
 <p>看到这里，可能大家会有疑问？什么样的函数和什么样的lambda表达式属于同一类型？答案是参数和返回值的类型共同决定函数的类