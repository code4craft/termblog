<h2>Jsoup代码解读之六-parser(下)</h2><div class="BlogContent">
 <p>最近生活上有点忙，女儿老是半夜不睡，精神状态也不是很好。工作上的事情也谈不上顺心，有很多想法但是没有几个被认可，有些事情也不是说代码写得好就行的。算了，还是端正态度，毕竟资历尚浅，我还是继续我的。</p> 
 <p>读Jsoup源码并非无聊，目的其实是为了将webmagic做的更好一点，毕竟parser也是爬虫的重要组成部分之一。读了代码后，收获也不少，对HTML的知识也更进一步了。</p> 
 <span id="OSC_h2_1"></span> 
 <h2>DOM树产生过程</h2> 
 <p>这里单独将<code>TreeBuilder</code>部分抽出来叫做语法分析过程可能稍微不妥，其实就是根据Token生成DOM树的过程，不过我还是沿用这个编译器里的称呼了。</p> 
 <p><code>TreeBuilder</code>同样是一个facade对象，真正进行语法解析的是以下一段代码：</p> 
 <pre class="brush: java; auto-links: false;">protected void runParser() {
    while (true) {
        Token token = tokeniser.read();

        process(token);

        if (token.type == Token.TokenType.EOF)
            break;
    }
}</pre> 
 <p><code>TreeBuilder</code>有两个子类，<code>HtmlTreeBuilder</code>和<code>XmlTreeBuilder</code>。<code>XmlTreeBuilder</code>自然是构建XML树的类，实现颇为简单，基本上是维护一个栈，并根据不同Token插入节点即可：</p> 
 <pre class="brush: java; auto-links: false;">@Override
protected boolean process(Token token) {
    // start tag, end tag, doctype, comment, character, eof
    switch (token.type) {
        case StartTag:
            insert(token.asStartTag());
            break;
        case EndTag:
            popStackToClose(token.asEndTag());
            break;
        case Comment:
            insert(token.asComment());
            break;
        case Character:
            insert(token.asCharacter());
            break;
        case Doctype:
            insert(token.asDoctype());
            break;
        case EOF: // could put some normalisation here if desired
            break;
        default:
            Validate.fail(&quot;Unexpected token type: &quot; + token.type);
    }
    return true;
}</pre> 
 <p><code>insertNode</code>的代码大致是这个样子(为了便于展示，对方法进行了一些整合)：</p> 
 <pre class="brush: java; auto-links: false;">Element insert(Token.StartTag startTag) {
    Tag tag = Tag.valueOf(startTag.name());
    Element el = new Element(tag, baseUri, startTag.attributes);
    stack.getLast().appendChild(el);
    if (startTag.isSelfClosing()) {
        tokeniser.acknowledgeSelfClosingFlag();
        if (!tag.isKnownTag()) // unknown tag, remember this is self closing for output. see above.
            tag.setSelfClosing();
    } else {
        stack.add(el);
    }
    return el;
}</pre> 
 <span id="OSC_h2_2"></span> 
 <h2>HTML解析状态机</h2> 
 <p>相比<code>XmlTreeBuilder</code>，<code>HtmlTreeBuilder</code>则实现较为复杂，除了类似的栈结构以外，还用到了<code>HtmlTreeBuilderState</code>来构建了一个状态机来分析HTML。这是为什么呢？不妨看看<code>HtmlTreeBuilderState</code>到底用到了哪些状态吧（在代码中中用&lt;!– State: –\&gt;标明状态）：</p> 
 <pre class="brush: html; auto-links: false;">&lt;!-- State: Initial --&gt;
&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;
&lt;!-- State: BeforeHtml --&gt;
&lt;html lang='zh-CN' xml:lang='zh-CN' xmlns='http://www.w3.org/1999/xhtml'&gt;
&lt;!-- State: BeforeHead --&gt;
&lt;head&gt;
  &lt;!-- State: InHead --&gt;
  &lt;script type=&quot;text/javascript&quot;&gt;
  //&lt;!-- State: Text --&gt;
    function xx(){
    }
  &lt;/script&gt;
  &lt;noscript&gt;
    &lt;!-- State: InHeadNoscript --&gt;
    Your browser does not support JavaScript!
  &lt;/noscript&gt;
&lt;/head&gt;
&lt;!-- State: AfterHead --&gt;
&lt;body&gt;
&lt;!-- State: InBody --&gt;
&lt;textarea&gt;
    &lt;!-- State: Text --&gt;
    xxx
&lt;/textarea&gt;
&lt;table&gt;
    &lt;!-- State: InTable --&gt;
    &lt;!-- State: InTableText --&gt;
    xxx
    &lt;tbody&gt;
    &lt;!-- State: InTableBody --&gt;
    &lt;/tbody&gt;
    &lt;tr&gt;
        &lt;!-- State: InRow --&gt;
        &lt;td&gt;
            &lt;!-- State: InCell --&gt;
        &lt;/td&gt;
    &lt;/tr&gt;    
&lt;/table&gt;
&lt;/html&gt;</pre> 
 <p>这里可以看到，HTML标签是有嵌套要求的，例如<code>&lt;tr&gt;</code>,<code>&lt;td&gt;</code>需要组合<code>&lt;table&gt;</code>来使用。根据Jsoup的代码，可以发现，<code>HtmlTreeBuilderState</code>做了以下一些事情：</p> 
 <ul> 
  <li><span id="OSC_h3_3"></span><h3>语法检查</h3> <p>例如<code>tr</code>没有嵌套在<code>table</code>标签内，则是一个语法错误。当<code>InBody</code>状态直接出现以下tag时，则出错。Jsoup里遇到这种错误，会发现这个Token的解析并记录错误，然后继续解析下面内容，并不会直接退出。</p> <pre class="brush: java; auto-links: false;">InBody {
    boolean process(Token t, HtmlTreeBuilder tb) {
        if (StringUtil.in(name,
        &quot;caption&quot;, &quot;col&quot;, &quot;colgroup&quot;, &quot;frame&quot;, &quot;head&quot;, &quot;tbody&quot;, &quot;td&quot;, &quot;tfoot&quot;, &quot;th&quot;, &quot;thead&quot;, &quot;tr&quot;)) {
        tb.error(this);
        return false;
        }
    }</pre> </li> 
  <li><span id="OSC_h3_4"></span><h3>标签补全</h3> <p>例如<code>head</code>标签没有闭合，就写入了一些只有body内才允许出现的标签，则自动闭合<code>&lt;/head&gt;</code>。<code>HtmlTreeBuilderState</code>有的方法<code>anythingElse()</code>就提供了自动补全标签，例如<code>InHead</code>状态的自动闭合代码如下：</p> <pre class="brush: java; auto-links: false;">private boolean anythingElse(Token t, TreeBuilder tb) {
        tb.process(new Token.EndTag(&quot;head&quot;));
        return tb.process(t);
    }</pre> <p>还有一种标签闭合方式，例如下面的代码：</p> <pre class="brush: java; auto-links: false;">private void closeCell(HtmlTreeBuilder tb) {
    if (tb.inTableScope(&quot;td&quot;))
        tb.process(new Token.EndTag(&quot;td&quot;));
    else
        tb.process(new Token.EndTag(&quot;th&quot;)); // only here if th or td in scope
}</pre> </li> 
 </ul> 
 <span id="OSC_h2_5"></span> 
 <h2>实例研究</h2> 
 <span id="OSC_h3_6"></span> 
 <h3>缺少标签时，会发生什么事？</h3> 
 <p>好了，看了这么多parser的源码，不妨回到我们的日常应用上来。我们知道，在页面里多写一个两个未闭合的标签是很正常的事，那么它们会被怎么解析呢？</p> 
 <p>就拿<code>&lt;div&gt;</code>标签为例：</p> 
 <ol> 
  <li><p>漏写了开始标签，只写了结束标签</p> <pre class="brush: java; auto-links: false;">case EndTag:
    if (StringUtil.in(name,&quot;div&quot;,&quot;dl&quot;, &quot;fieldset&quot;, &quot;figcaption&quot;, &quot;figure&quot;, &quot;footer&quot;, &quot;header&quot;, &quot;pre&quot;, &quot;section&quot;, &quot;summary&quot;, &quot;ul&quot;)) {                
        if (!tb.inScope(name)) {
        tb.error(this);
        return false;
        } 
    }</pre> <p>恭喜你，这个<code>&lt;/div&gt;</code>会被当做错误处理掉，于是你的页面就毫无疑问的乱掉了！当然，如果单纯多写了一个<code>&lt;/div&gt;</code>，好像也不会有什么影响哦？(记得有人跟我讲过为了防止标签未闭合，而在页面底部多写了几个<code>&lt;/div&gt;</code>的故事)</p> </li> 
  <li><p>写了开始标签，漏写了结束标签</p> <p>这个情况分析起来更复杂一点。如果是无法在内部嵌套内容的标签，那么在遇到不可接受的标签时，会进行闭合。而<code>&lt;div&gt;</code>标签可以包括大多数标签，这种情况下，其作用域会持续到HTML结束。</p> </li> 
 </ol> 
 <p>好了，parser系列算是分析结束了，其